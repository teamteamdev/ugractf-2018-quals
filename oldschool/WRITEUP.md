# Old school: Write-up

Файл не запускается в режиме совместимости ни с одной виндой (у разработчика таска на 64-битной системе не вышло). Попробуем узнать, что же за файл нам дали, командой `file SOFTWARE.EXE`:

```
SOFTWARE.EXE: MS-DOS executable, MZ for MS-DOS
```

Если открыть программу, например, в IDA Pro, то мы можем дизассемблировать её, но не можем декомпилировать.

* IDA64 не дает: `Please use ida (not ida64) to decompile current file` — значит, не 64-битная
* IDA32 тоже: `only 32bit functions can be decompiled` — значит, и не 32-битная

Постойте, мы же работаем с программой под DOS — она наверняка 16-битная. И правда, это несложно понять по двухбуквенным именам регистров (`ax`, `bx` и так далее).

Итак, путей решения два:

## Запустить

Поставим DOSBox, запустим, нас спросят число. Не знаем :(

Придется пользоваться вторым способом.

## Читать ассемблер

Давайте разбираться с ассемблером, раз у нас больше ничего нет.

> Кстати, у нас есть немного функций. Возможно, вы слышали о соглашениях вызовов функций, и для большего понимания кода было бы здорово понять, на каком языке написана программа. 
> 
> Способов понять не так уж и много. Один из них — посмотреть на используемые имена функций. И сразу всё становится понятно: `Write`, `WriteLn`, `ReadLn` и подобные функции намекают на Pascal.
>
> Программа была написана на Pascal и скомпилирована компилятором Turbo Pascal 6.0 (антиквариат из 1990). [Исходный код](private/SOFTWARE.PAS) (_не стоит смотреть, если вам интересно дочитать райтап_).

Тут всё не очень сложно, если немного знать ассемблер. Сначала выводится `Secret storage`, потом `Enter key`.

Затем читается какая-то переменная (IDA подсказывает, что она типа `longint`, и поэтому старшие биты пишутся в `dx`, а младшие в `ax`), помещается куда-то в память (по адресу `0x10992`), потом обратно возвращается в `ax`.

> Необходимо `ax` переместить в память, а затем взять обратно, потому что иначе `ax` может затереться запуском `readln` (возвращаемое значение функции обычно кладется в регистр `ax`).

Далее регистр `ax` побитово логически умножается на `0x25` (командой `and ax, 25h`) и сравнивается с `0x24`.

Если сравнение прошло неуспешно, то происходит переход на `0x00AD`, где выводится сообщение `fail!`. Если успешно — запускается какой-то страшный кусок кода. Разбираться в нём можно, но не очень-то и нужно. Мы уже знаем, что ключ — число, которое при побитовом `and` с `0x25` (=37) дает `0x24` (=36). _Забавно_, но подходит очень много чисел. Например, само число 36.

Теперь осталось вернуться к первому способу и запустить.

Вообще, если покопаться в остальном коде, то можно понять, что при успешной проверке 30 байт начиная с `0x10932` ксорятся с `0x95` (=149) и выводятся на экран, так тоже можно получить флаг.

Флаг: **ugra_i_l3ve_01d_sch001_s0_mU5h**
