# Crypto Loader: Write-up

Посмотрим, что делает приведенный код на Python.

Сразу видим парные функции: `(bad|good)_(ciphering|encrypting)`. Что они делают?

* `bad_ciphering` делает ксор
* `good_ciphering` делает ксор первого аргумента `level` раз со вторым
* `bad_encrypting` делает ROT13 (сдвиг Цезаря на 13)
* `good_encrypting` делает ROT13 `level` раз

Почему же `good_ciphering` и `good_encrypting` не настолько надежны, насколько кажутся?

Давайте сделаем xor два раза: `a ^ b ^ b`. Заметим, что в `b` и в `b` все биты совпадают, поэтому `b ^ b == 0`. Значит, `a ^ b ^ b == a`. Отсюда следует, что `a ^ b ^ b .. ^ b` равно либо `a` (если количество `b` четно), либо `a ^ b` (если нечетно).

В нашем коде `good_ciphering` вызывается 1 337 раз — значит, это просто xor.

С `good_encrypting` ещё веселее: два раза `rot13` восстанавливает исходный текст (для латиницы). Соответственно, четное число применений `rot13` вообще не изменят текст — а у нас их ровно 228.

Что же за зверь `requests` и куда идет запрос? Немного подумав, видим, что `plaintext` — это ксор шифротекста и восьмибайтного ключа, который вводится с клавиатуры.

И `requests` как раз запрашивает страницу `plaintext`, то есть он пытается считать эту строку ссылкой. Значит, она и есть ссылка.

Отсюда получаем, что либо первые семь байт plaintext равны `http://`, либо первые восемь — `https://`. Попытавшись порасшифровывать `http://`, получаем бинарный мусор, а вот с `https://` всё хорошо. Из первых восьми байт шифротекста и восьми байт открытого текста ксором получаем ключ — `elonmusk`.

Вводим его на вход и получаем флаг, **228 раз зашифрованный ROT13**. Думаю, расшифровать это не составит труда.

Флаг: **ugractf_xor_is_very_bad_cryptoalgo**
